---
title: "UAD"
format: html
editor: visual
---

## 

```{r, message=FALSE}
library(readxl) #Package for reading in excel data
library(tidyverse) # Package for data cleaning and processing

```

```{r}
UAD <- read_excel("UADSRAMETOverview19902009 20230720.xlsx")

head(UAD) # the data is originally formated in a way that has each Year and Month as a column names with specific stages as row values. 
tail(UAD)

UAD <- UAD %>% pivot_longer(c(6:40), names_to = "Year", values_to = "stage") # Change the data format from wider to longer format, making Year as rownames and stages as values.

UAD$Month <- gsub("[[:digit:]]", "", UAD$Year) #create new column for Month
UAD$Year <- gsub("M","", UAD$Year) #Remove all M (May) from Year
UAD$Year <- gsub("J","",UAD$Year) #Remove all J (July) from Year
UAD$Year <- gsub("N","",UAD$Year) #Remove all N (June) from Year

head(UAD)
tail(UAD)

UAD$Month <- gsub("M","May", UAD$Month) #replace all M with May 
UAD$Month <- gsub("J","July",UAD$Month) #replace all J with July
UAD$Month <- gsub("N","June",UAD$Month) #replace all N with June

#UAD <- UAD %>% filter(!stage == "NA") # remove all NA's
head(UAD)
tail(UAD)
```

```{r}
# Create a function to tidy up Year values
replace.yr <- function(x){
  y <- x
  for(i in 1:length(x)){
    if(x[i] == 90){
      y[i] <- 1990
    } else if(x[i] == 91){
      y[i] <- 1991
    }else if(x[i] == 92){
      y[i] <- 1992
    }else if(x[i] == 93){
      y[i] <- 1993
    }else if(x[i] == 94){
     y[i] <- 1994
    }else if(x[i] == 95){
      y[i] <- 1995
    }else if(x[i] == 96){
      y[i] <- 1996
    }else if(x[i] == 97){
      y[i] <- 1997
    }else if(x[i] == 98){
      y[i] <- 1998
    }else if(x[i] == 99){
      y[i] <- 1999
    } else if(x[i] == 00){
      y[i] <- 2000
    }else if(x[i] == 01){
      y[i] <- 2001
    }else if(x[i] == 02){
      y[i] <- 2002
    }else if(x[i] == 03){
     y[i] <- 2003
    }else if(x[i] == 04){
      y[i] <- 2004
    }else if(x[i] == 05){
      y[i] <- 2005
    }else if(x[i] == 06){
      y[i] <- 2006
    }else if(x[i] == 07){
      y[i] <- 2007
    }else if(x[i] == 08){
      y[i] <- 2008
    } else if(x[i] == 09){
      y[i] <- 2009
    } else {
      y[i] <- x[i]
    }
      
  } 
  return(y)
}

unique(UAD$Year)

UAD$Year <- as.numeric(UAD$Year) # Year is treated as a character variable, use this code to change it to numeric variable. You have to do this first before applying the function "replace.yr".

UAD$Year <- replace.yr(UAD$Year) #Everything looks good now.

head(UAD)
tail(UAD)

unique(UAD$stage) # check for unique stages


UAD$stage.modify <- gsub("p","Pulled.tag", UAD$stage) #replace p as Pulled.tag
UAD$stage.modify <- gsub("x","not.tagged", UAD$stage.modify) #replace p as not.tag
UAD$stage.modify <- gsub("m","MR", UAD$stage.modify) #replace m as Multiple Rosette
#UAD$stage.modify <- gsub("w2","MR", UAD$stage.modify) #replace w2 as Multiple Flowering
UAD$stage.modify <- gsub("MR2","MR", UAD$stage.modify) #replace m2 as Multiple Rosette
#UAD$stage.modify <- gsub("MR5","MR", UAD$stage.modify) #replace m5 as Multiple Rosette
#UAD$stage.modify <- gsub("MR3","MR", UAD$stage.modify) #replace m3 as Multiple Rosette
UAD$stage.modify <- gsub("F","SF", UAD$stage.modify) #replace F as Single Flowering
UAD$stage.modify <- gsub("r","SR", UAD$stage.modify) #replace r as Single Rosette
UAD$stage.modify <- gsub("G2","MF", UAD$stage.modify) #replace G2 as Multiple Flowering
#UAD$stage.modify <- gsub("G3","MF", UAD$stage.modify) #replace G3 as Multiple Flowering
UAD$stage.modify <- gsub("s","Seedling", UAD$stage.modify) #replace s as Seedling

UAD <- UAD %>% 
 mutate(    
   stage.modify = case_when(
     stage.modify == "n" ~ "no.ramet",
    TRUE ~ stage.modify
 ))



unique(UAD$stage.modify) # check to see if all stages are renamed correctly

head(UAD)
tail(UAD)

###########################
UAD <- UAD %>% select(!stage)

UAD_Dem.both <- UAD %>% filter(Year %in% c(1990, 1991,1992,1993,1994,1995,1996,1997,1998,1999))
UAD_Dem.both <- UAD_Dem.both %>% pivot_wider(names_from = "Month", values_from = "stage.modify")
UAD_Dem.both <- UAD_Dem.both %>% filter(!(is.na(May)&is.na(July)))
UAD_Dem.both <- UAD_Dem.both %>% pivot_longer(c(May, July), names_to = "Month", values_to = "stage.modify")

#########################
UAD_Dem.2002 <- UAD %>% filter(Year == 2002) %>% pivot_wider(names_from = "Month",                    values_from = "stage.modify") %>% filter(!(is.na(May)&is.na(June)))
UAD_Dem.2002 <- UAD_Dem.2002%>%pivot_longer(c(May, June), names_to = "Month", values_to = "stage.modify")

######################
UAD_Dem.bolt <- UAD %>% filter(Year %in% c(2000, 2001, 2003,2004))%>% pivot_wider(names_from =                                "Month",values_from = "stage.modify") %>% filter(!(is.na(May)&is.na(July)))
UAD_Dem.bolt <-UAD_Dem.bolt%>%pivot_longer(c(May, July), names_to = "Month", values_to = "stage.modify")

#####################
UAD_Dem.sing <- UAD %>% filter(Year %in% c(2005, 2006, 2007, 2008, 2009)) %>% filter(!is.na(stage.modify))

UAD <- rbind(UAD_Dem.both, UAD_Dem.2002, UAD_Dem.bolt, UAD_Dem.sing)

UAD <- UAD %>%
 mutate(    
   stage.modify = case_when(is.na(stage.modify) ~ "no.ramet",
    TRUE ~ stage.modify
 )) 
```

```{r}
# Create a column that is able to track and assign duplicate (late observations) observations per a year
UAD1 <- UAD %>% mutate(hash = str_c(RAMET, Year)) %>% #join RAMET and Year to a single column
  group_by(hash) %>% 
 mutate(dupl_id = seq(n())) %>% # Create a column that identifies an observation as duplicate
 ungroup () 

#################Working on data from 1990-1999###################
# filter on data from 1990-1999
UAD_both <- UAD1 %>% filter(Year %in% c(1990, 1991,1992,1993,1994,1995,1996,1997,1998,1999))

# filter cases where the observations in July were "no.ramet" or "Dead"
Null.July <- UAD_both %>% filter(Month == "July" & stage.modify == "no.ramet")

Null.uni <- unique(Null.July$hash) # Store the unique records of "no.ramet" or "Dead" observations in July

July.True <- UAD_both %>% filter(Month == "July") # Filter only July observations
July.True <- July.True[!(July.True$hash %in% Null.uni),] #Remove records of "no.ramet" or "Dead" observations in July from July only dataframe.

May.True <- UAD_both %>% filter(Month == "May") # Filter only May data
May.seed <- May.True[(May.True$dupl_id=="1" & (May.True$stage.modify == "Seedling")),]
Seed.uni <- unique(May.seed$hash) # Store the unique records of seedling observations in May
July.True <- July.True[!(July.True$hash %in% Seed.uni),] #remove records of No seedling in July but seedlings in May


May.True <- May.True[(May.True$hash %in% Null.uni),] #maintain required May data to be substituted for "no.ramet" or "Dead" observations in July

May.True <- May.True %>% filter(stage.modify != "Seedling")

UAD_both <- rbind(May.True, July.True, May.seed) # Combine required May and July data

UAD_both <- UAD_both %>% select(!c(hash, dupl_id)) # Remove unwanted columns


#############Working on data that was repeated for only flowered ramets###########
UAD_bolt <- UAD1 %>% filter(Year %in% c(2000, 2001, 2003,2004)) #filter required years

# Remove all late observations that did not flower. They appeared as no.ramet
UAD_bolt <- UAD_bolt[!(UAD_bolt$dupl_id=="2" & !(UAD_bolt$stage.modify%in%c("SF", "MF"))),]

# Filter out only duplicate that flowered
du.fit1 <- UAD_bolt  %>% filter(dupl_id=="2")

#Create a unique values of the hash column for flowering late observations
un1 <- unique(du.fit1$hash)


# Remove cases where the ramet flowered in late observations but did not flower in the early observations
UAD_bolt  <- UAD_bolt[!(UAD_bolt$hash %in% un1  & UAD_bolt$Month %in% c("May", "June")),]

#Check if there is still duplicate observations in a single year
UAD_bolt$duplicated <- duplicated(UAD_bolt [, "hash"])

# Check complete, data is valid.
unique(UAD_bolt $duplicated)

UAD_bolt <- UAD_bolt %>% select(!c(hash, dupl_id, duplicated))

##################Years with only one observation (JUNE)######################
UAD_June <- UAD1 %>% filter(Year %in% c( 2008, 2009))
UAD_June <- UAD_June %>% select(!c(hash, dupl_id))

##################Years with only one observation (July)######################
UAD_July <- UAD1 %>% filter(Year %in% c(2005, 2006, 2007))
UAD_July <- UAD_July %>% select(!c(hash, dupl_id))

################Working on 2002 and 2005#########################
UAD_2002 <- UAD1 %>% filter(Year == 2002)# Filter only 2002 data
#UAD_2002 <- UAD_2002 %>% filter(Month == "June") # Filter only June data

Null.June <- UAD_2002 %>% filter(Month == "June" & stage.modify == "no.ramet")
Null.June  
Null.uniq1 <- unique(Null.June $hash) # Store the unique records of "no.ramet" or "Dead" observations in July

June.True  <- UAD_2002 %>% filter(Month == "June") # Filter only July observations
June.True  <- June.True[!(June.True$hash %in% Null.uniq1),] #Remove records of "no.ramet" or "Dead" observations in July from July only dataframe.

May.True1 <- UAD_2002 %>% filter(Month == "May") # Filter only May data
#Filtering only seedlings in May
May.seed1 <- May.True1[(May.True1$dupl_id=="1" & (May.True1$stage.modify == "Seedling")),] 
May.seed1 # no seedling data recorded
#Seed.uni1 <- unique(May.seed1$hash) # Store the unique records of seedling observations in May
#July.True <- July.True[!(July.True$hash %in% Seed.uni1),] #remove records of No seedling in July but seedlings in May

May.True1 <- May.True1[(May.True1$hash %in% Null.uniq1),] #maintain required May data to be substituted for "no.ramet" or "Dead" observations in July

UAD_2002 <- rbind(May.True1, June.True)

UAD_2002 <- UAD_2002 %>% select(!c(hash, dupl_id))

UAD <- rbind(UAD_both, UAD_bolt, UAD_2002, UAD_July, UAD_June)

UAD <- UAD %>% arrange(RAMET, Year)


UAD <- UAD %>% filter(!(stage.modify == "Pulled.tag")) #Remove "pulled.tag" (90 observations)
```

```{r}
#http://ctszkin.com/2012/03/11/generating-a-laglead-variables/#comments
### First Part#####

### This code build a new column that is able to detect previous stage of the ramet, but also depends on the stage of the ramet in for each year.
buildPrevSize <- function(x){
  sort1 <- paste(x$Year, x$RAMET) # ID can be a character, year must be numeric
  sort2 <- paste(x$Year-1, x$RAMET)
  index_lag<-match(sort2, sort1)
  x$PrevStage <- x$stage.modify[index_lag]
  x$PrevYear <- x$Year[index_lag]
  x
}


### This code build a new column that is able to detect next stage of the ramet, but also depends on the stage of the ramet in the specific month of the year. That is, June/July records the current year matches with June/July records in the next year. The same is true for May records. 
buildNextSize <- function(x){
  sort1 <- paste(x$Year, x$RAMET) # ID can be a character, year must be numeric
  sort2 <- paste(x$Year+1, x$RAMET)
  index_lead<-match(sort2, sort1)
  # cool ... na values are where they should be, no previous results
  #table(Astragalus[is.na(index_lag),"Year"])
  # hotdamn! this works, so now
  x$NextStage <- x$stage.modify[index_lead]
  x$NextYear <- x$Year[index_lead]
  x
}


### This code build a new column that is able to detect first stage of the ramet and the last stage. 
buildStartStopYears <- function(x){
  first_last <- x %>% 
    filter(!is.na(stage.modify)) %>% 
    group_by(RAMET) %>% 
    arrange(RAMET, Year) %>% 
    summarize(firstYear = first(Year),
              firstStage = first(stage.modify),
              lastYear = last(Year),
              lastStage = last(stage.modify))
  x <- left_join(x, first_last)
  x
}

is_true <- function(x){
  is.logical(x) & !is.na(x) & x
} 


UAD <- buildPrevSize(UAD) %>% 
  filter(#!(is_true(PrevStage=="no.ramet") & is_true(stage.modify == "no.ramet")),
          !(is_true(PrevStage=="Pulled.tag") & is_true(stage.modify == "Pulled.tag")),
         #!(is.na(PrevStage) & is_true(stage.modify == "no.ramet")),
         !(is_true(PrevStage == "Pulled.tag") & is_true(stage.modify == "no.ramet"))) %>% 
  mutate(PrevStage = case_when(PrevStage == "no.ramet" ~ NA_character_, #set no.ramet to NA
                               TRUE ~ PrevStage))

## Apply the three functions created above
UAD2 <- (buildPrevSize(UAD) %>% 
  buildNextSize() %>% 
  buildStartStopYears())

########################################################################
#UAD3 <- UAD2 %>% group_by(RAMET) %>% filter(!(Year == min(Year) & stage.modify == "no.ramet" & is.na(NextStage)))
```

```{r}
intro.pd <- function(x, y, z){
          D <- x
          for(i in 1:length(x)){
            if (x[i] == "no.ramet"  &  z[i]  %in% c("MF", "MR","SF","SR", "no.ramet", na.rm = TRUE)){ D[i] <-"inactive"} #sprouting from prolonged dormancy
           else if (x[i] == "no.ramet"  &  y[i]  %in% c("MF", "MR","SF","SR", "Seedling","no.ramet", na.rm = TRUE)){ D[i] <-"inactive"} #entering prolonged dormancy
            else if (x[i] == "no.ramet" & z[i] %in% c("no.ramet", na.rm = TRUE)){ D[i] <-"inactive"} # staying in prolonged dormancy for more than a year
            else if (x[i] == "no.ramet"  & y[i] %in% c("no.ramet", na.rm = TRUE)){ D[i] <-"inactive"} # staying in prolonged dormancy
            else {D[i] <- x[i]
          }
            
        }
        return(D)
}

UAD2$stage.modified <- intro.pd(UAD2$stage.modify, UAD2$PrevStage, UAD2$NextStage)


#Special cases
UAD2 <- UAD2 %>% 
 mutate(    
   stage.modified = case_when(
     Year == 2008 & stage.modified == "inactive" & NextStage == "no.ramet" ~ "no.ramet", #we need at least three year to determine dormancy.
       Year == 2009 & stage.modified == "inactive" ~ "no.ramet", #2009 cannot be inactive 
    TRUE ~ stage.modified
 ))

##############################################################################
# I do not see the essence of keeping no.ramet in both 2008 and 2009. After all, it does not add any information to the data. 
UAD2 <- UAD2 %>% filter(!(Year == 2008 & stage.modified == "no.ramet" & NextStage == "no.ramet")) %>% filter(!(Year == 2009 & stage.modified == "no.ramet"))


```

```{r}
UAD3 <- UAD2 %>% select(SPECIES, SITE, PLOT, Year, Month, NEWROS, RAMET, stage.modified)


### This code build a new column that is able to detect previous stage of the ramet, but also depends on the stage of the ramet in the specific month of the year. That is, June/July records the current year matches with June/July records in the previous year. The same is true for May records. 
buildPrevSize <- function(x){
  sort1 <- paste(x$Year, x$RAMET) # ID can be a character, year must be numeric
  sort2 <- paste(x$Year-1, x$RAMET)
  index_lag<-match(sort2, sort1)
  x$PrevStage <- x$stage.modified[index_lag]
  x$PrevYear <- x$Year[index_lag]
  x
}


### This code build a new column that is able to detect next stage of the ramet, but also depends on the stage of the ramet in the specific month of the year. That is, June/July records the current year matches with June/July records in the next year. The same is true for May records. 
buildNextSize <- function(x){
  sort1 <- paste(x$Year, x$RAMET) # ID can be a character, year must be numeric
  sort2 <- paste(x$Year+1, x$RAMET)
  index_lead<-match(sort2, sort1)
  x$NextStage <- x$stage.modified[index_lead]
  x$NextYear <- x$Year[index_lead]
  x
}

#is_true <- function(x){
 # is.logical(x) & !is.na(x) & x
#} 


### This code build a new column that is able to detect first stage of the ramet and the last stage. 
buildStartStopYears <- function(x){
  first_last <- x %>% 
    filter(!is.na(stage.modified)) %>% 
    group_by(RAMET) %>% 
    arrange(RAMET, Year) %>% 
    summarize(firstYear = first(Year),
              firstStage = first(stage.modified),
              lastYear = last(Year),
              lastStage = last(stage.modified))
  x <- left_join(x, first_last)
  x
}


#UAD4 <- buildPrevSize(UAD4) %>% 
#  filter(#!(is_true(PrevStage=="no.ramet") & is_true(stage.modified == "no.ramet")),
#         !(is_true(PrevStage=="Pulled.tag") & is_true(stage.modified == "Pulled.tag")),
         #!(is.na(PrevStage) & is_true(stage.modified == "no.ramet")),
 #        !(is_true(PrevStage == "Pulled.tag") & is_true(stage.modified == "no.ramet"))) %>% 
 # mutate(PrevStage = case_when(PrevStage == "no.ramet" ~ NA_character_, #set no.ramet to NA
  #                             TRUE ~ PrevStage))


## Apply the three functions created above
UAD3 <- (buildPrevSize(UAD3) %>% 
  buildNextSize() %>% 
  buildStartStopYears())



with(UAD3, table(stage.modified, PrevStage, useNA = "always"))


```

```{r}
# Create a functuon for survival analysis
UAD3$Survival <- "Yes"

UAD3 <- UAD3 %>% 
 mutate(    
   Survival = case_when(stage.modified == "SF" ~ "No",
                        stage.modified == "MF" ~ "No",
                        stage.modified == "Seedling" & is.na(NextStage) ~ "No",
                        stage.modified == "SR" & is.na(NextStage) ~ "No",
                        stage.modified == "MR" & is.na(NextStage) ~ "No",
                        #stage.modified == "Seedling" & NextStage == "Dead" ~ "No",
                        #stage.modified == "SR" & NextStage == "Dead" ~ "No",
                        #stage.modified == "MR" & NextStage == "Dead" ~ "No",
                        #stage.modify == "no.ramet" & NextStage == "Dead" ~ "No",
                        Year == "2007" & stage.modified == "not.tagged"  ~ NA,
                        Year == "2008" & stage.modified == "not.tagged"  ~ NA,
                        Year == "2009" & stage.modified == "not.tagged"  ~ NA,
                        NextStage == "not.tagged" ~ NA,
    TRUE ~ Survival
 ))

UAD3$Survival[UAD3$Year == "2009" & UAD3$stage.modified == "MR"] <- NA
UAD3$Survival[UAD3$Year == "2009" & UAD3$stage.modified == "SR"] <- NA
UAD3$Survival[UAD3$Year == "2009" & UAD3$stage.modified == "Seedling"] <- NA
UAD3$Survival[UAD3$Year == "2009" & UAD3$stage.modified == "inactive"] <- NA


UAD3 %>% filter(PrevStage == "SF" & stage.modified %in% c("inactive", "MR", "SR", "Seedling"))

UAD3 %>% filter(PrevStage == "Seedling" & stage.modified == "inactive")

```

```{r}
#########################################################
UAD3 <- UAD3  %>% group_by(RAMET) %>%
 mutate(    
   PrevStage = case_when(is.na(PrevStage) & Year == min(Year) ~ "First.Appearance",
    TRUE ~ PrevStage
 ))  

UAD3 <- UAD3  %>% group_by(RAMET) %>%
 mutate(    
   PrevStage = case_when(PrevStage == "First.Appearance" & Year == 1990 ~ "No.record",
    TRUE ~ PrevStage
 ))  


UAD3 <- UAD3 %>% group_by(RAMET) %>%
 mutate(    
   NextStage = case_when(is.na(NextStage) & Year == max(Year)  ~ "Dead",
    TRUE ~ NextStage
 )) 

UAD3$NextStage[UAD3$Year == "2009" & UAD3$stage.modified == "MR"] <- NA
UAD3$NextStage[UAD3$Year == "2009" & UAD3$stage.modified == "SR"] <- NA
UAD3$NextStage[UAD3$Year == "2009" & UAD3$stage.modified == "Seedling"] <- NA
UAD3$NextStage[UAD3$Year == "2009" & UAD3$stage.modified == "inactive"] <- NA



with(UAD3, table(stage.modified, PrevStage, useNA = "always"))

with(UAD3, table(NextStage, stage.modified, useNA = "always"))

with(UAD3, table(PrevStage == "MF", stage.modified %in% c("inactive", "MR", "SR", "Seedling")))

with(UAD3, table(PrevStage == "SF", stage.modified %in% c("inactive", "MR", "SR")))

UAD3 %>% filter(NextStage == "Dead" & stage.modified == "inactive")
```

```{r}
write_csv(UAD3, "UAD_single.csv")
```

```{r}
library(reshape2)
UAD.surv <- dcast(UAD3,  Year ~ Survival, value.var = "Survival")
UAD.surv <- UAD.surv %>% transform(Total = No + Yes) %>% transform(Prop.survival = ((Total - No)/Total)*100)


UAD.stage <- dcast(UAD3,  Year ~ stage.modified, value.var = "stage.modified")
UAD.rec <- dcast(UAD3,  Year ~ PrevStage, value.var = "PrevStage")

UAD.stage <- cbind(UAD.stage, Recruitment = UAD.rec$First.Appearance)

UAD.stage <- UAD.stage %>% 
  rowwise() %>% 
  mutate(Total = sum(inactive, MF, MR, Seedling, SF, SR, na.rm = TRUE)) %>%
  mutate(Prop.inactive = ((Total-sum(MF, MR, Seedling, SF, SR))/Total)*100,
         Prop.MF = ((Total-sum(inactive, MR, Seedling, SF, SR))/Total)*100,
         Prop.MR = ((Total-sum(inactive, MF, Seedling, SF, SR))/Total)*100,
         Prop.Seedling = ((Total-sum(inactive, MR, MF, SF, SR))/Total)*100,
         Prop.SF = ((Total-sum(inactive, MR, Seedling, MF, SR))/Total)*100,
         Prop.SR = ((Total-sum(inactive, MR, Seedling, SF, MF))/Total)*100,
         Prop.Rec = ((Total-(Total-Recruitment))/Total)*100)

UAD.surv$Site <- "UAD"
UAD.stage$Site <- "UAD"
```
